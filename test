repeat task.wait() until game:IsLoaded()

_G.Configs = {
    ["Mission Difficulty"]  = "Auto",   --‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏Å Easy,Normal,Hard,Severe,Aberrant
    ["Farm Mode"]           = "Normal", --Normal ‡∏Å‡∏±‡∏ö OP  || ‡∏ñ‡πâ‡∏≤ Normal ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö‡∏û‡∏ß‡∏Å‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ Skill ‡πÅ‡∏ï‡πà‡∏ñ‡πâ‡∏≤ OP ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö‡∏û‡∏ß‡∏Å‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏™‡∏Å‡∏¥‡∏•
    ["Modifiers"]           = {
        "No Perks",
        "No Skills",
        "No Talents",
        "Nightmare",
        "Injury Prone",
        "Chronic Injuries",
        "Fog",
        "Glass Cannon",
        "Time Trial",
        "Boring",
        "Simple",
    },
    ["BASE_WAIT_TIME"]      = 23,                   --‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏∂‡∏á 20 ‡∏ß‡∏¥‡∏à‡∏∞‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏Ü‡πà‡∏≤‡∏ï‡∏±‡∏ß‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ **‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏´‡πâ‡∏≤‡∏°‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤ 20
    ["PositionXY"]          = { x = 497, y = 433 }, -- 497,433=pc // 586,428=emu
    ["MaxChecks"]           = 0,                    --‡∏õ‡∏£‡∏±‡∏ö 0 ‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏±‡∏û‡∏à‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏´‡∏°‡∏î
    ["Rejoin_Second"]       = 100,                  --‡∏ñ‡πâ‡∏≤‡∏°‡∏±‡∏ô afk ‡πÄ‡∏Å‡∏¥‡∏ô 100 ‡∏ß‡∏¥‡∏à‡∏∞‡∏£‡∏µ‡∏à‡∏≠‡∏¢‡πÉ‡∏´‡πâ‡πÄ‡∏≠‡∏á
    ["Auto Create Mission"] = true,                 --‡∏™‡∏£‡πâ‡∏≤‡∏á mission ‡πÄ‡∏≠‡∏á **‡∏ï‡∏≠‡∏ô‡∏≠‡∏±‡∏û‡πÄ‡∏Å‡∏£‡∏î gear ‡πÉ‡∏´‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏≠‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô false
    ["Auto Upgrade Gear"]   = true,                 --‡∏≠‡∏±‡∏û‡πÄ‡∏Å‡∏£‡∏î gear ‡πÑ‡∏ß‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡∏≠‡∏ô‡∏•‡∏á‡∏°‡∏¥‡∏ä‡∏ä‡∏±‡πà‡∏ô‡πÑ‡∏õ‡∏™‡∏±‡∏Å‡∏£‡∏∞‡∏¢‡∏∞ ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏≠‡∏±‡∏û
    ["Rejoin"]              = true,                 --‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏£‡∏µ‡∏à‡∏≠‡∏¢ **‡∏ï‡∏≠‡∏ô‡∏≠‡∏±‡∏û‡πÄ‡∏Å‡∏£‡∏î gear ‡πÉ‡∏´‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏≠‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô false
    --["AutoUnlockAndEquipSkill"] = false, --‡πÑ‡∏ß‡πâ unlock ‡πÅ‡∏•‡∏∞ check ‡∏ß‡πà‡∏≤ equip ‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
}


-- Utility to run scripts concurrently
local function RunConcurrent(fn)
    task.spawn(fn)
end

-- === ma
RunConcurrent(function()
    repeat task.wait() until game:IsLoaded()
    getgenv().HorstConfig = {
        ["EnableLog"] = true,         -- ‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô true ‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏≤‡∏Å‡πÉ‡∏´‡πâ‡∏°‡∏±‡∏ô‡πÄ‡∏ä‡πá‡∏Ñ‡∏Ç‡∏≠‡∏á
        ["Whitescreen"] = false,
        ["EnableAddFriends"] = false, -- ‡πÅ‡∏≠‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏≠‡∏á ‡∏ó‡∏∏‡∏Å‡πÜ 1‡∏ô‡∏≤‡∏ó‡∏µ
        ["LockFps"] = {
            ["EnableLockFps"] = true,
            ["LockFpsAmount"] = 14
        }
    }
    loadstring(game:HttpGet("https://raw.githubusercontent.com/HorstSpaceX/last_update/main/on_loaded.lua"))()
end)

--- === First Log
RunConcurrent(function()
    -- MainSave.lua
    -- ‡∏™‡∏£‡πâ‡∏≤‡∏á/‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÑ‡∏ü‡∏•‡πå JSON ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô (‡πÑ‡∏°‡πà‡∏ö‡∏ß‡∏Å numberRoundPlay)
    repeat task.wait() until game:IsLoaded()
    task.wait(1)
    local folderName = "PlayersData"
    local Players = game:GetService("Players")
    local HttpService = game:GetService("HttpService")
    local player = Players.LocalPlayer
    local filename = folderName .. "/" .. player.Name .. ".json"

    if game.PlaceId == 14916516914 then
        -- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ
        if not isfolder(folderName) then
            makefolder(folderName)
        end

        -- ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        local data = {
            name = player.Name,
            prestigeLevel = 0,
            goldWorkSpace = 0,
            gemWorkSpace = 0,
            isReadyEquidReloadSkill = true,
            isReadyUnloackTwoSkill = true,
            isReadyEquidPerk = true,
            missionDif = "Easy",
            continueToFindPerk = 0,
            numberRoundPlay = 0,                   -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0
            level = 0,                             -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0
            continueMission = 0,                   -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0
            rejoinThreshold = math.random(60, 80), -- ‡∏™‡∏∏‡πà‡∏°‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å
            savedAt = os.time()
        }

        -- ‡∏ñ‡πâ‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏´‡πâ‡πÇ‡∏´‡∏•‡∏î‡∏Ñ‡πà‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÑ‡∏°‡πà‡∏ö‡∏ß‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°)
        if isfile and isfile(filename) then
            local content = readfile(filename)
            local oldData = HttpService:JSONDecode(content)

            -- ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏ß‡πâ
            if oldData.prestigeLevel ~= nil then
                data.prestigeLevel = oldData.prestigeLevel
            end
            if oldData.goldWorkSpace ~= nil then
                data.goldWorkSpace = oldData.goldWorkSpace
            end
            if oldData.gemWorkSpace ~= nil then
                data.gemWorkSpace = oldData.gemWorkSpace
            end
            if oldData.isReadyEquidReloadSkill ~= nil then
                data.isReadyEquidReloadSkill = oldData.isReadyEquidReloadSkill
            end
            if oldData.isReadyUnloackTwoSkill ~= nil then
                data.isReadyUnloackTwoSkill = oldData.isReadyUnloackTwoSkill
            end
            if oldData.isReadyEquidPerk ~= nil then
                data.isReadyEquidPerk = oldData.isReadyEquidPerk
            end
            if oldData.missionDif ~= nil then
                data.missionDif = oldData.missionDif
            end
            if oldData.continueToFindPerk ~= nil then
                data.continueToFindPerk = oldData.continueToFindPerk
            end
            if oldData.numberRoundPlay ~= nil then
                data.numberRoundPlay = oldData.numberRoundPlay
            end
            if oldData.level ~= nil then
                data.level = oldData.level
            end
            if oldData.continueMission ~= nil then
                data.continueMission = oldData.continueMission
            end
            if oldData.rejoinThreshold ~= nil then
                data.rejoinThreshold = oldData.rejoinThreshold
            end
        end

        -- ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà
        local ok, err = pcall(function()
            writefile(filename, HttpService:JSONEncode(data))
        end)

        if not ok then
            warn("Failed to write file for " .. player.Name .. ": " .. tostring(err))
        else
            print("Current numberRoundPlay =", data.numberRoundPlay, "| rejoinThreshold =", data.rejoinThreshold)
        end
    end
end)

-- === REJOIN_BYPASS ===
RunConcurrent(function()
    repeat task.wait() until game:IsLoaded()

    local function rejoinServer()
        local ts = game:GetService("TeleportService")
        local p = game:GetService("Players").LocalPlayer
        ts:TeleportToPlaceInstance(game.PlaceId, game.JobId, p)
    end

    function MainSequence()
        task.wait(_G.Configs["Rejoin_Second"])
        rejoinServer()
    end

    if _G.Configs["Rejoin"] == true then
        MainSequence()
    end
end)

-- === SCRIPT1_2 ===
if game.PlaceId == 15220308770 then
    RunConcurrent(function()
        local folderName = "PlayersData"
        local Players = game:GetService("Players")
        local HttpService = game:GetService("HttpService")
        local player = Players.LocalPlayer
        local filename = folderName .. "/" .. player.Name .. ".json"

        if not isfile or not isfile(filename) then
            warn("File not found: " .. filename)
            return
        end

        local ok, data = pcall(function()
            local content = readfile(filename)
            return HttpService:JSONDecode(content)
        end)

        local isReadyEquidReloadSkillScript = data.isReadyEquidReloadSkill
        local isReadyUnloackTwoSkill = data.isReadyUnloackTwoSkill
        -- ========================================
        -- COMBINED ROBLOX SCRIPT
        -- Phase 1: Titan Script -> Phase 2: Naruto Script
        -- ========================================
        if not (isReadyUnloackTwoSkill) then
            repeat task.wait() until game:IsLoaded()
            task.wait(2)
            -- ========================================
            -- PHASE 1: TITAN SCRIPT (CODE NO. 1)
            -- ========================================

            local VirtualInputManager = game:GetService("VirtualInputManager")
            local titanFolder = workspace:WaitForChild("Titans")

            local pressed1 = false
            local pressed2 = false
            local stopLoop = false

            local LocalPlayer = Players.LocalPlayer
            local function WaitForCharacter()
                local startTime = tick()
                repeat
                    task.wait(0.1)
                    if tick() - startTime > 30 then -- Timeout after 30 seconds
                        return false
                    end
                until LocalPlayer.Character
                    and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    and not LocalPlayer.Character:FindFirstChild("ForceField")

                task.wait(1) -- Reduced wait time
                return true
            end

            -- Optimized HUD waiting with timeout
            local function WaitForKillHUD()
                local startTime = tick()

                while tick() - startTime < 20 do -- 20 second timeout
                    local success, result = pcall(function()
                        local gui = LocalPlayer:FindFirstChild("PlayerGui")
                        if not gui then return false end

                        local hudPath = gui:FindFirstChild("Interface")
                        if not hudPath then return false end

                        hudPath = hudPath:FindFirstChild("HUD")
                        if not hudPath then return false end

                        hudPath = hudPath:FindFirstChild("Objectives")
                        if not hudPath then return false end

                        hudPath = hudPath:FindFirstChild("Main")
                        if not hudPath then return false end

                        hudPath = hudPath:FindFirstChild("Slay")
                        if not hudPath then return false end

                        local text = hudPath.Text
                        return text and string.match(text, "%[(%d+)%/") ~= nil
                    end)

                    if success and result then
                        return true
                    end

                    task.wait(0.5)
                end

                return false
            end


            if not WaitForCharacter() then
                error("‚ùå Failed to load character for Phase 2")
            end

            WaitForKillHUD()

            -- Function to anchor character to prevent movement
            local function AnchorCharacter()
                local character = player.Character
                if not character then return end

                local hrp = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChildOfClass("Humanoid")

                if hrp then
                    hrp.Anchored = true
                    -- Store original position
                    return hrp.CFrame
                end
                return nil
            end

            -- Function to unanchor character
            local function UnanchorCharacter()
                local character = player.Character
                if not character then return end

                local hrp = character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Anchored = false
                end
            end

            -- ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° 1 (with anti-movement)
            task.delay(1.5, function()
                local originalPos = AnchorCharacter()

                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.One, false, game)
                task.wait(0.1)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.One, false, game)

                -- Wait a bit for skill animation, then restore position
                task.wait(0.5)
                if originalPos then
                    local character = player.Character
                    local hrp = character and character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.CFrame = originalPos
                    end
                end

                UnanchorCharacter()
                pressed1 = true
            end)

            -- ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° 2 (with anti-movement)
            task.delay(4, function()
                local originalPos = AnchorCharacter()

                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
                task.wait(0.1)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Two, false, game)

                -- Wait a bit for skill animation, then restore position
                task.wait(0.5)
                if originalPos then
                    local character = player.Character
                    local hrp = character and character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.CFrame = originalPos
                    end
                end

                UnanchorCharacter()
                pressed2 = true
            end)

            -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏´‡∏¢‡∏∏‡∏î loop ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î‡∏Ñ‡∏£‡∏ö
            task.spawn(function()
                while not stopLoop do
                    if pressed1 and pressed2 then
                        stopLoop = true
                    end
                    task.wait(0.1)
                end
            end)

            -- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡πÑ‡∏ó‡∏ó‡∏±‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            local function getAllTitansInFolder(folder)
                local titans = {}

                for _, descendant in pairs(folder:GetDescendants()) do
                    if descendant:FindFirstChild("HumanoidRootPart") then
                        table.insert(titans, descendant)
                    end
                end

                return titans
            end

            -- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏¢‡πâ‡∏≤‡∏¢‡πÅ‡∏•‡∏∞‡∏Ç‡∏¢‡∏≤‡∏¢ Nape
            local function moveAllNapesLowerInFront()
                local character = player.Character
                if not character then return end

                local hrp = character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end

                local distance = 30
                local dropAmount = 5
                local lookVector = hrp.CFrame.LookVector
                local frontPosition = hrp.Position + lookVector * distance
                local loweredPosition = frontPosition - Vector3.new(0, dropAmount, 0)

                local allTitans = getAllTitansInFolder(titanFolder)

                for _, titan in pairs(allTitans) do
                    local nape = titan:FindFirstChild("Hitboxes", true)
                        and titan.Hitboxes:FindFirstChild("Hit", true)
                        and titan.Hitboxes.Hit:FindFirstChild("Nape")

                    if nape and nape:IsA("BasePart") then
                        nape.Size = Vector3.new(50, 50, 50)
                        nape.CFrame = CFrame.new(loweredPosition, loweredPosition + lookVector)
                    end
                end
            end

            -- Loop ‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á Phase 1
            while true do
                if stopLoop then
                    break
                end
                moveAllNapesLowerInFront()
                task.wait(0.05)
            end
        end

        -- ========================================
        -- TRANSITION PHASE
        -- ========================================


        -- ========================================
        -- PHASE 2: NARUTO SCRIPT (CODE NO. 2)
        -- ========================================

        --setfpscap(17) -- Increased from 15 for smoother performance
        task.wait(math.random(1, 2))

        -- IncrementNumber.lua
        -- Increment numberRoundPlay ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå JSON ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô

        local TeleportService = game:GetService("TeleportService")

        -- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô rejoinServer
        local function rejoinServer()
            TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
        end

        if (data.isReadyUnloackTwoSkill) then
            -- ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ numberRoundPlay ‡πÉ‡∏´‡πâ +1 ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å 1
            data.numberRoundPlay = (data.numberRoundPlay or 0) + 1

            -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏ß‡∏•‡∏≤ save ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            data.savedAt = os.time()

            -- ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
            local ok2, err = pcall(function()
                writefile(filename, HttpService:JSONEncode(data))
            end)

            if not ok then
                warn("Failed to update numberRoundPlay for " .. player.Name .. ": " .. tostring(err))
            else
                print("numberRoundPlay updated:", data.numberRoundPlay, "| rejoinThreshold =", data.rejoinThreshold)
            end

            -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ñ‡∏∂‡∏á‡∏£‡∏≠‡∏ö‡∏™‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
            if data.rejoinThreshold and data.numberRoundPlay >= data.rejoinThreshold then
                task.wait(math.random(5, 10)) -- ‡∏Å‡∏±‡∏ô‡∏ä‡∏ô‡∏Å‡∏±‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏à‡∏≠
                data.numberRoundPlay = 0
                local okSir, err = pcall(function()
                    writefile(filename, HttpService:JSONEncode(data))
                end)
                rejoinServer()
            end
        end


        -- ‡∏ï‡∏£‡∏ß‡∏à‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏°‡∏¥‡∏ä‡∏ä‡∏±‡πà‡∏ô‡∏ï‡πà‡∏≠ ‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤ xp ‡∏à‡∏∞‡∏Ñ‡∏£‡∏ö ‡πÅ‡∏°‡πâ‡πÄ‡∏•‡πÄ‡∏ß‡∏•‡∏à‡∏∞‡∏ï‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡πá‡∏ï‡∏≤‡∏°
        if (data.continueMission ~= 0) then
            data.continueMission = (data.continueMission) - 1
        end
        if (data.level == 100 and data.prestigeLevel == 0) or (data.prestigeLevel == 1 and data.level == 125)
            and (data.continueMission == 0) then
            rejoinServer()
        end

        -- ‡∏ï‡∏£‡∏ß‡∏à‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏°‡∏¥‡∏ä‡∏ä‡∏±‡πà‡∏ô‡∏ï‡πà‡∏≠ ‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏´‡∏≤ perk ‡πÄ‡∏à‡∏≠ ‡πÅ‡∏°‡πâ‡πÄ‡∏•‡πÄ‡∏ß‡∏•‡∏à‡∏∞‡∏ï‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡πá‡∏ï‡∏≤‡∏°
        -- if (data.level == 150 and data.prestigeLevel == 2) and (data.continueToFindPerk == 0) and (data.isReadyEquidPerk) then
        --     rejoinServer()
        -- end
        -- if (data.continueToFindPerk ~= 0) then
        --     data.continueToFindPerk = (data.continueToFindPerk) - 1
        -- end
        writefile(filename, HttpService:JSONEncode(data))


        -- Services
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local UserInputService = game:GetService("UserInputService")
        local VirtualInputManager = game:GetService("VirtualInputManager")
        local RunService = game:GetService("RunService")
        local TweenService = game:GetService("TweenService")

        -- Remotes with better error handling
        local Assets = ReplicatedStorage:WaitForChild("Assets", 10)
        if not Assets then
            return
        end

        local Remotes = Assets:WaitForChild("Remotes", 10)
        if not Remotes then
            return
        end

        local POST = Remotes:WaitForChild("POST", 10)
        local GET = Remotes:WaitForChild("GET", 10)

        if not POST or not GET then
            return
        end

        local LocalPlayer = Players.LocalPlayer

        -- CONFIGURATION SECTION
        -- Base wait time before allowing last titan kill (in seconds)
        if (data.missionDif == "Aberrant") or (data.missionDif == "Severe") then
            _G.Configs["BASE_WAIT_TIME"] = 15
        elseif (data.missionDif == "Hard") then
            _G.Configs["BASE_WAIT_TIME"] = 20
        end
        local BASE_WAIT_TIME = _G.Configs["BASE_WAIT_TIME"] -- Change this value as needed

        -- Random delay range to add to the base wait time
        -- Set the minimum and maximum additional seconds to add to the base wait time
        -- Example: {1, 3} will add 1-3 random seconds, {1, 5} will add 1-5 random seconds
        local RANDOM_DELAY_CONFIG = { 2, 5 } -- Change these values as needed

        -- Optimized Variables
        local State = {
            baitDummy = nil,
            lastKillValue = -1,
            lastKillTime = tick(),
            lastReloadedKill = -5,
            hasEscaped = false,
            noKillCount = 0,
            isAttacking = false,
            lastActionTime = tick(),
            maxIdleTime = 8, -- Reduced for better responsiveness
            isImmortal = false,
            lastHealthCheck = 0,
            titanCache = {},
            lastTitanCheck = 0,
            gameStartTime = tick(), -- Track when the game/script started
            randomDelayTime = 0     -- Will store the random delay time
        }

        -- Optimized character waiting
        local function WaitForCharacter()
            local startTime = tick()
            repeat
                task.wait(0.1)
                if tick() - startTime > 30 then -- Timeout after 30 seconds
                    return false
                end
            until LocalPlayer.Character
                and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                and not LocalPlayer.Character:FindFirstChild("ForceField")

            task.wait(1) -- Reduced wait time
            return true
        end

        -- Optimized HUD waiting with timeout
        local function WaitForKillHUD()
            local startTime = tick()

            while tick() - startTime < 20 do -- 20 second timeout
                local success, result = pcall(function()
                    local gui = LocalPlayer:FindFirstChild("PlayerGui")
                    if not gui then return false end

                    local hudPath = gui:FindFirstChild("Interface")
                    if not hudPath then return false end

                    hudPath = hudPath:FindFirstChild("HUD")
                    if not hudPath then return false end

                    hudPath = hudPath:FindFirstChild("Objectives")
                    if not hudPath then return false end

                    hudPath = hudPath:FindFirstChild("Main")
                    if not hudPath then return false end

                    hudPath = hudPath:FindFirstChild("Slay")
                    if not hudPath then return false end

                    local text = hudPath.Text
                    return text and string.match(text, "%[(%d+)%/") ~= nil
                end)

                if success and result then
                    return true
                end

                task.wait(0.5)
            end

            return false
        end

        -- Function to generate random delay time (called once at script start)
        local function GenerateRandomDelay()
            if #RANDOM_DELAY_CONFIG >= 2 then
                local minDelay = math.min(RANDOM_DELAY_CONFIG[1], RANDOM_DELAY_CONFIG[2])
                local maxDelay = math.max(RANDOM_DELAY_CONFIG[1], RANDOM_DELAY_CONFIG[2])
                return math.random(minDelay, maxDelay)
            else
                return 0 -- No delay if config is invalid
            end
        end

        -- Function to check if required time has passed since game start (base time + random delay)
        local function HasRequiredTimePassed()
            local requiredTime = BASE_WAIT_TIME + State.randomDelayTime
            return (tick() - State.gameStartTime) >= requiredTime
        end

        -- Function to get total required wait time
        local function GetTotalRequiredTime()
            return BASE_WAIT_TIME + State.randomDelayTime
        end

        -- Optimized dummy creation
        local function CreateBaitDummy()
            pcall(function()
                if State.baitDummy then
                    State.baitDummy:Destroy()
                    State.baitDummy = nil
                end

                local char = LocalPlayer.Character
                if not char or not char.PrimaryPart then return end

                State.baitDummy = char:Clone()
                State.baitDummy.Name = "BaitDummy_" .. math.random(1000, 9999)
                State.baitDummy.Parent = workspace

                -- Position dummy above character
                State.baitDummy:SetPrimaryPartCFrame(char.PrimaryPart.CFrame * CFrame.new(0, 8, 0))

                -- Optimize dummy properties in batch
                local descendants = State.baitDummy:GetDescendants()
                for i = 1, #descendants do
                    local part = descendants[i]
                    if part:IsA("BasePart") then
                        part.Anchored = true
                        part.CanCollide = false
                        part.Material = Enum.Material.ForceField -- Lighter rendering
                    elseif part:IsA("Humanoid") then
                        part.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
                        part.PlatformStand = true
                        part.BreakJointsOnDeath = false
                        part.Health = part.MaxHealth
                    end
                end
            end)
        end

        -- Optimized hiding function
        local function HideCharacter()
            local char = LocalPlayer.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            if root then
                root.CFrame = CFrame.new(math.random(-100, 100), -5000, math.random(-100, 100))
            end
        end

        -- Optimized invisibility function
        local function BecomeInvisible()
            local char = LocalPlayer.Character
            if not char then return end

            pcall(function()
                local descendants = char:GetDescendants()
                for i = 1, #descendants do
                    local obj = descendants[i]
                    if obj:IsA("BasePart") then
                        obj.Transparency = 1
                        obj.CanCollide = false
                    elseif obj:IsA("Decal") then
                        obj.Transparency = 1
                    elseif obj:IsA("ParticleEmitter") or obj:IsA("Beam") then
                        obj.Enabled = false
                    end
                end

                -- Handle accessories
                local children = char:GetChildren()
                for i = 1, #children do
                    local acc = children[i]
                    if acc:IsA("Accessory") then
                        local handle = acc:FindFirstChild("Handle")
                        if handle then
                            handle.Transparency = 1
                            handle.CanCollide = false
                        end
                    end
                end
            end)
        end

        -- Enhanced immortality system
        local function MakeImmortal()
            if State.isImmortal then return end

            local char = LocalPlayer.Character
            local humanoid = char and char:FindFirstChildOfClass("Humanoid")
            if not humanoid then
                return
            end

            pcall(function()
                -- Rename humanoid to avoid detection
                humanoid.Name = "H_" .. math.random(10000, 99999)

                -- Set immortal properties
                humanoid.MaxHealth = 1e6
                humanoid.Health = humanoid.MaxHealth
                humanoid.BreakJointsOnDeath = false
                humanoid.RequiresNeck = false

                -- Continuous health monitoring (optimized)
                local healthConnection
                healthConnection = RunService.Heartbeat:Connect(function()
                    if not humanoid or not humanoid.Parent or not char or not char.Parent then
                        if healthConnection then
                            healthConnection:Disconnect()
                        end
                        State.isImmortal = false
                        return
                    end

                    -- Only check health every 0.1 seconds for performance
                    local currentTime = tick()
                    if currentTime - State.lastHealthCheck >= 0.1 then
                        State.lastHealthCheck = currentTime
                        if humanoid.Health < humanoid.MaxHealth * 0.9 then
                            humanoid.Health = humanoid.MaxHealth
                        end
                    end
                end)

                State.isImmortal = true
                HideCharacter()
                CreateBaitDummy()
            end)
        end

        -- Optimized reload function
        local function Reload()
            pcall(function()
                local gasStation = workspace:FindFirstChild("Unclimbable")
                if gasStation then
                    gasStation = gasStation:FindFirstChild("Reloads")
                    if gasStation then
                        gasStation = gasStation:FindFirstChild("GasTanks")
                        if gasStation then
                            gasStation = gasStation:FindFirstChild("Refill")
                            if gasStation then
                                POST:FireServer("Attacks", "Reload", gasStation)
                                State.lastActionTime = tick()
                                return
                            end
                        end
                    end
                end

                -- Fallback reload
                POST:FireServer("Attacks", "Reload")
                State.lastActionTime = tick()
            end)
        end

        -- Optimized R key press
        local function PressR()
            pcall(function()
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, false, game)
                task.wait(0.05) -- Reduced wait time
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.R, false, game)
                State.lastActionTime = tick()
            end)
        end

        -- Smoother teleportation around nape
        local function TeleportAroundNape(nape, count, radius)
            local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not root or not nape then return false end

            pcall(function()
                local baseHeight = 8
                for i = 1, count do
                    local angle = math.rad((360 / count) * i + math.random(-15, 15))
                    local currentRadius = radius + math.random(-1, 1)
                    local height = baseHeight + math.sin(tick() * 3 + i) * 2

                    local offsetX = math.cos(angle) * currentRadius
                    local offsetZ = math.sin(angle) * currentRadius

                    local targetCFrame = nape.CFrame * CFrame.new(offsetX, height, offsetZ)
                    root.CFrame = targetCFrame

                    task.wait(0.03) -- Smoother movement
                end
            end)
            return true
        end

        -- Optimized kill count function
        local function GetCurrentKillCount()
            local success, result = pcall(function()
                local gui = LocalPlayer.PlayerGui
                local text = gui.Interface.HUD.Objectives.Main.Slay.Text
                return tonumber(string.match(text, "%[(%d+)%/"))
            end)
            return success and result or State.lastKillValue
        end

        -- Enhanced titan attack function
        local function AttackTitan(titan)
            if State.isAttacking then return end
            State.isAttacking = true

            local success = pcall(function()
                -- Find nape with better error handling
                local hitboxes = titan:FindFirstChild("Hitboxes", true)
                if not hitboxes then
                    return
                end

                local hit = hitboxes:FindFirstChild("Hit")
                if not hit then
                    return
                end

                local nape = hit:FindFirstChild("Nape")
                if not nape then
                    return
                end


                -- Prepare for attack
                BecomeInvisible()
                MakeImmortal()

                -- Optimize nape hitbox
                nape.Size = Vector3.new(25, 25, 25) -- Larger hitbox for better hit detection
                nape.CanCollide = false
                nape.Transparency = 1
                nape.Shape = Enum.PartType.Ball -- Better collision detection

                -- Enhanced teleportation
                if not TeleportAroundNape(nape, 3, 5) then
                    return
                end

                -- Improved attack sequence
                local attackSequence = {
                    function() POST:FireServer("Attacks", "Slash", true) end,
                    function() task.wait(0.02) end,
                    function() POST:FireServer("Hitboxes", "Register", nape, 9999, 0.05) end,
                    function() task.wait(0.02) end,
                    function() POST:FireServer("Attacks", "Slash", false) end
                }

                for i, action in ipairs(attackSequence) do
                    action()
                end

                -- Check kill progress
                local currentKill = GetCurrentKillCount()
                if currentKill and currentKill > State.lastKillValue then
                    State.lastKillValue = currentKill
                    State.lastKillTime = tick()
                    State.lastActionTime = tick()
                    State.hasEscaped = false
                    State.noKillCount = 0
                end

                -- Smart escape mechanism
                local timeSinceKill = tick() - State.lastKillTime
                if timeSinceKill >= 2 and not State.hasEscaped then
                    State.hasEscaped = true
                    POST:FireServer("Attacks", "Slash_Escape")
                    State.lastKillTime = tick()
                end

                -- Smart reload system
                if currentKill and currentKill % 5 == 0 and currentKill ~= State.lastReloadedKill then
                    Reload()
                    State.lastReloadedKill = currentKill
                end

                -- Timeout handling
                if timeSinceKill >= 4 then
                    PressR()
                    Reload()
                    State.lastKillTime = tick()
                    State.noKillCount = State.noKillCount + 1

                    if State.noKillCount >= 2 then
                        PressR()
                        State.noKillCount = 0
                    end
                end
            end)

            State.isAttacking = false
            State.lastActionTime = tick()
        end

        -- Optimized visibility restoration
        local function MakeVisible()
            local char = LocalPlayer.Character
            if not char then return end

            pcall(function()
                local descendants = char:GetDescendants()
                for i = 1, #descendants do
                    local part = descendants[i]
                    if part:IsA("BasePart") then
                        part.Transparency = 0
                        part.CanCollide = true
                    elseif part:IsA("Decal") then
                        part.Transparency = 0
                    elseif part:IsA("ParticleEmitter") or part:IsA("Beam") then
                        part.Enabled = true
                    end
                end

                local children = char:GetChildren()
                for i = 1, #children do
                    local acc = children[i]
                    if acc:IsA("Accessory") then
                        local handle = acc:FindFirstChild("Handle")
                        if handle then
                            handle.Transparency = 0
                            handle.CanCollide = true
                        end
                    end
                end
            end)
        end

        -- Enhanced script reset
        local function ResetScript()
            pcall(function()
                if State.baitDummy then
                    State.baitDummy:Destroy()
                    State.baitDummy = nil
                end
            end)

            State.lastKillValue = -1
            State.lastKillTime = tick()
            State.lastReloadedKill = -5
            State.hasEscaped = false
            State.noKillCount = 0
            State.isAttacking = false
            State.lastActionTime = tick()
            State.isImmortal = false
            State.titanCache = {}
            State.lastTitanCheck = 0
            -- Don't reset gameStartTime as we want to keep track from the very beginning
        end

        -- Optimized titan detection with caching
        local function GetTitans()
            local currentTime = tick()
            if currentTime - State.lastTitanCheck < 0.2 then -- Cache for 0.2 seconds
                return State.titanCache
            end

            State.lastTitanCheck = currentTime
            State.titanCache = {}

            local success, titans = pcall(function()
                local titanFolder = workspace:FindFirstChild("Titans")
                return titanFolder and titanFolder:GetChildren() or {}
            end)

            if success then
                -- Filter valid titans
                for i = 1, #titans do
                    local titan = titans[i]
                    if titan and titan.Parent and titan:FindFirstChild("Hitboxes", true) then
                        table.insert(State.titanCache, titan)
                    end
                end
            end

            return State.titanCache
        end

        -- Function to check if we should attack the last titan
        local function ShouldAttackLastTitan(titanCount)
            if titanCount ~= 1 then
                return true -- Not the last titan, attack normally
            end

            -- This is the last titan, check if required time has passed
            return HasRequiredTimePassed()
        end

        -- Initialize Phase 2

        if not WaitForCharacter() then
            error("‚ùå Failed to load character for Phase 2")
        end

        WaitForKillHUD()
        ResetScript()

        -- Generate the random delay time once at the start
        State.randomDelayTime = GenerateRandomDelay()

        -- Main optimized loop for Phase 2
        while true do
            local loopStart = tick()

            -- Anti-hang protection
            if tick() - State.lastActionTime > State.maxIdleTime then
                ResetScript()
                PressR()
            end

            -- Character validation
            local char = LocalPlayer.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") then
                LocalPlayer:LoadCharacter()
                WaitForKillHUD()
                ResetScript()
                task.wait(1)
            end

            -- Get titans with caching
            local titans = GetTitans()

            if #titans == 0 then
                task.wait(1)
            elseif #titans == 1 then
                -- Single titan strategy with timing check
                if not ShouldAttackLastTitan(#titans) then
                    -- Wait for required time to pass before attacking the last titan
                    local timeRemaining = GetTotalRequiredTime() - (tick() - State.gameStartTime)
                    if timeRemaining > 0 then
                        task.wait(1)
                    end
                end

                if State.baitDummy then
                    pcall(function() State.baitDummy:Destroy() end)
                    State.baitDummy = nil
                end

                local titan = titans[1]
                pcall(function()
                    char:PivotTo(titan:GetPivot() * CFrame.new(0, 6, -12))
                    MakeVisible()
                end)

                AttackTitan(titan)
                task.wait(0.3)
            else
                -- Multiple titans strategy - attack all except potentially the last one
                for i = 1, #titans do
                    local isLastTitan = (i == #titans and #titans > 1) -- Check if this is the last titan in a multi-titan scenario

                    if not isLastTitan or ShouldAttackLastTitan(1) then
                        AttackTitan(titans[i])
                        task.wait(0.05)
                    end
                end
            end

            task.wait(0.05) -- Smooth loop timing
        end
    end)
end

-- === SLOT ===
if game.PlaceId == 13379208636 then
    RunConcurrent(function()
        repeat task.wait() until game:IsLoaded()

        local Players = game:GetService("Players")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local LocalPlayer = Players.LocalPlayer

        local function MainSequence()
            task.wait(15)
            local selectArgs = { "Functions", "Select", "A" }
            ReplicatedStorage.Assets.Remotes.GET:InvokeServer(unpack(selectArgs))

            local teleportArgs = { "Functions", "Teleport", "Lobby" }
            ReplicatedStorage.Assets.Remotes.GET:InvokeServer(unpack(teleportArgs))
        end

        local success, result = pcall(function()
            return LocalPlayer
                :WaitForChild("PlayerGui")
                :WaitForChild("Interface")
                :WaitForChild("Title_Screen")
                :WaitForChild("Slots").Name
        end)

        if success and typeof(result) == "string" then
            MainSequence()
        else
            warn("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á Slot ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà string")
        end
    end)
end

-- === CHECK_RETRY ===
if game.PlaceId == 15220308770 then
    RunConcurrent(function()
        -- ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏°‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
        repeat task.wait() until game:IsLoaded()

        -- ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏® Services
        local VirtualInputManager = game:GetService("VirtualInputManager")
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local UserInputService = game:GetService("UserInputService")
        local delayTime = math.random() * (3.7 - 1.0) + 1.0

        -- ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤
        local CONFIG = {
            CLICK_DELAY = 0.1,    -- ‡∏•‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏≠‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Ñ‡∏•‡∏¥‡∏Å
            CHECK_INTERVAL = 0.5, -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å 0.5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            INITIAL_WAIT = 5,     -- ‡∏£‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
            STUCK_TIMEOUT = 20,   -- ‡∏ñ‡πâ‡∏≤ Kill ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô 20 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡∏à‡∏∞‡∏Ñ‡∏•‡∏¥‡∏Å
            CLICK_POSITION = _G.Configs["PositionXY"],
        }

        -- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏° Kill count
        local lastKillCount = nil
        local lastChangeTime = tick()

        -- üñ± ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ã‡πâ‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏•‡πâ‡∏ß
        local function SimulateLeftClick(x, y)
            local pos = { x = x or CONFIG.CLICK_POSITION.x, y = y or CONFIG.CLICK_POSITION.y }


            -- ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏µ‡πà 1: ‡πÉ‡∏ä‡πâ VirtualInputManager (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á)
            local clickSuccess = pcall(function()
                -- ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÄ‡∏°‡∏≤‡∏™‡πå‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                VirtualInputManager:SendMouseMoveEvent(pos.x, pos.y, game)
                task.wait(CONFIG.CLICK_DELAY)

                -- ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ã‡πâ‡∏≤‡∏¢ - ‡πÉ‡∏ä‡πâ‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                -- SendMouseButtonEvent(x, y, button, pressed, game, [button_number])
                VirtualInputManager:SendMouseButtonEvent(pos.x, pos.y, 0, true, game, 1)
                task.wait(CONFIG.CLICK_DELAY)
                VirtualInputManager:SendMouseButtonEvent(pos.x, pos.y, 0, false, game, 1)
            end)

            if not clickSuccess then
                -- ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏µ‡πà 2: ‡πÉ‡∏ä‡πâ Mouse object (‡∏™‡∏≥‡∏£‡∏≠‡∏á)
                pcall(function()
                    if LocalPlayer and LocalPlayer:GetMouse() then
                        local mouse = LocalPlayer:GetMouse()

                        -- ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÄ‡∏°‡∏≤‡∏™‡πå‡∏î‡πâ‡∏ß‡∏¢‡∏ß‡∏¥‡∏ò‡∏µ‡∏≠‡∏∑‡πà‡∏ô
                        mouse.X = pos.x
                        mouse.Y = pos.y

                        -- ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ú‡πà‡∏≤‡∏ô Mouse events
                        for i = 1, 1 do -- ‡∏•‡∏î‡∏à‡∏≤‡∏Å 2 ‡πÄ‡∏õ‡πá‡∏ô 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á
                            if mouse.Button1Down then
                                mouse.Button1Down:Fire()
                            end
                            task.wait(CONFIG.CLICK_DELAY)
                            if mouse.Button1Up then
                                mouse.Button1Up:Fire()
                            end
                            task.wait(CONFIG.CLICK_DELAY)
                        end
                    end
                end)
            end

            -- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
            task.wait(0.1)
            local mouse = LocalPlayer:GetMouse()
            if mouse then
                local actualX, actualY = mouse.X, mouse.Y

                -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                local xDiff = math.abs(actualX - pos.x)
                local yDiff = math.abs(actualY - pos.y)
            end
        end

        -- üîç ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Kill count
        local function GetKillData()
            local success, result = pcall(function()
                local interface = LocalPlayer.PlayerGui:FindFirstChild("Interface")
                if not interface then return nil end

                local hud = interface:FindFirstChild("HUD")
                if not hud then return nil end

                local objectives = hud:FindFirstChild("Objectives")
                if not objectives then return nil end

                local main = objectives:FindFirstChild("Main")
                if not main then return nil end

                local slay = main:FindFirstChild("Slay")
                if not slay then return nil end

                return slay.Text
            end)

            return success and result or nil
        end

        -- üìä ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
        local function ParseKillText(text)
            if not text then return nil, nil end

            local current, max = string.match(text, "%[(%d+)%/(%d+)%]")
            return tonumber(current), tonumber(max)
        end

        -- üéØ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÅ‡∏•‡πâ‡∏ß
        local function MainSequence()
            while true do
                local killText = GetKillData()
                local currentTime = tick()

                if killText then
                    local currentKill, maxKill = ParseKillText(killText)

                    if currentKill and maxKill then
                        -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Kill count ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                        if lastKillCount ~= currentKill then
                            lastKillCount = currentKill
                            lastChangeTime = currentTime
                        end

                        -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                        if currentKill >= maxKill then
                            task.wait(delayTime)
                            SimulateLeftClick()
                            task.wait(delayTime)
                            SimulateLeftClick()
                            task.wait(delayTime)
                            SimulateLeftClick()
                            break
                        end

                        -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Kill ‡∏Ñ‡πâ‡∏≤‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô timeout ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                        local timeSinceLastChange = currentTime - lastChangeTime
                        if timeSinceLastChange >= CONFIG.STUCK_TIMEOUT then
                            task.wait(delayTime)
                            SimulateLeftClick()
                            task.wait(delayTime)
                            SimulateLeftClick()
                            lastChangeTime = currentTime -- ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÄ‡∏ß‡∏•‡∏≤
                            task.wait(delayTime)         -- ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
                        end
                    end
                else
                end
                task.wait(CONFIG.CHECK_INTERVAL)
            end
        end

        -- üîß ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
        local function Initialize()
            task.wait(CONFIG.INITIAL_WAIT)

            -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ LocalPlayer ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
            if not LocalPlayer then
                return
            end


            -- ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
            lastChangeTime = tick()

            -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏Å
            local success, err = pcall(MainSequence)
            if not success then
                return
            end
        end

        -- üß™ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Ñ‡∏•‡∏¥‡∏Å (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°)
        local function TestClick()
            SimulateLeftClick()
        end

        -- ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏î‡∏™‡∏≠‡∏ö
        _G.TestClick = TestClick

        Initialize()
    end)
end

-- === MISSION ===
if game.PlaceId == 14916516914 then
    RunConcurrent(function()
        repeat task.wait() until game:IsLoaded()
        task.wait(10)

        local VirtualInputManager = game:GetService("VirtualInputManager")
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer

        function SimulateLeftClick(x, y)
            VirtualInputManager:SendMouseMoveEvent(x, y, game)
            task.wait()

            VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 0)
            task.wait()
            VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 0)
            task.wait()
        end

        local EquipmentButton = player.PlayerGui.Interface.Topbar.Main.Categories.Equipment.Interact
        local perkButtonGUI = game:GetService("Players").LocalPlayer.PlayerGui.Interface.Equipment.Categories.Perks.Main
            .Interact
        local PrestigeMenuButton = player.PlayerGui.Interface.Equipment.Categories.Prestige.Main.Interact


        local interact = function(path)
            game:GetService("GuiService").SelectedObject = path
            task.wait()
            if game:GetService("GuiService").SelectedObject == path then
                game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.Return, false, game)
                game:GetService("VirtualInputManager"):SendKeyEvent(false, Enum.KeyCode.Return, false, game)
                task.wait()
            end
            game:GetService("GuiService").SelectedObject = nil
            task.wait(0.01)
        end

        interact(EquipmentButton)
        task.wait(1)
        interact(EquipmentButton)
        task.wait(1)
        interact(EquipmentButton)
        task.wait(3)
        interact(PrestigeMenuButton)
        task.wait(1)
        interact(PrestigeMenuButton)
        task.wait(1)
        interact(PrestigeMenuButton)
        task.wait(3)

        local skillPointTextTest = player.PlayerGui.Interface.Equipment.Categories.Skill_Tree.Main.Title.Text
        local skillPointTest = tonumber(skillPointTextTest:match("%[(%d+) SP%]"))
        if skillPointTest == nil then
            SimulateLeftClick(136, 475)
			task.wait(0.5)
			SimulateLeftClick(136, 475)
            task.wait(3)
            interact(EquipmentButton)
            task.wait(1)
            interact(EquipmentButton)
            task.wait(1)
            interact(EquipmentButton)
            task.wait(3)
            interact(PrestigeMenuButton)
            task.wait(1)
            interact(PrestigeMenuButton)
            task.wait(1)
            interact(PrestigeMenuButton)
            task.wait(3)
        end
		local skillPointText = player.PlayerGui.Interface.Equipment.Categories.Skill_Tree.Main.Title.Text
        local skillPoint = tonumber(skillPointText:match("%[(%d+) SP%]"))



        local XPtext = player.PlayerGui.Interface.Equipment.Prestige.Progress.XP.Text
        local cleanXPText = XPtext:gsub(",", "")
        local myXp, maxHp = cleanXPText:match("(%d+)%s*/%s*(%d+)")

        local textLevelGui = player.PlayerGui.Interface.Gear_Up.HUD.Level.Title.Text
        local LevelGui = tonumber(textLevelGui:match("%d+"))
        local LevelGuiString = tostring(LevelGui)

        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RemoteFunction = ReplicatedStorage.Assets.Remotes.GET

        local goldText = Players.LocalPlayer.PlayerGui.Interface.Topbar.Main.Currencies.Gold.Amount.Text
        local gemText = game:GetService("Players").LocalPlayer.PlayerGui.Interface.Topbar.Main.Currencies.Gems.Amount
            .Text

        local gradeText = Players.LocalPlayer.PlayerGui.Interface.Equipment.Categories.Upgrades.Main.Title.Text
        local extractedGrade = string.match(gradeText, "%[(%a%+?%-?)%s*GRADE%]")





        local gearRanks = {
            "E-", "E", "E+",
            "D-", "D", "D+",
            "C-", "C", "C+",
            "B-", "B", "B+",
            "A-", "A", "A+",
            "S-", "S", "S+"
        }

        local upgrades = {
            "ODM_Range",
            "ODM_Control",
            "ODM_Speed",
            "ODM_Gas",
            "ODM_Damage",
            "Blade_Durability",
            "Crit_Chance",
            "Crit_Damage"
        }


        local function parseNumberText(text)
            -- ‡∏•‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢ , ‡∏≠‡∏≠‡∏Å‡∏Å‡πà‡∏≠‡∏ô
            text = text:gsub(",", "")

            local number, suffix = text:match("(%d+%.?%d*)([KMB]?)")
            number = tonumber(number)

            if not number then
                return 0
            end

            if suffix == "K" then
                number = number * 1e3
            elseif suffix == "M" then
                number = number * 1e6
            elseif suffix == "B" then
                number = number * 1e9
            end

            return number
        end

        local gold = parseNumberText(goldText)
        local gem = parseNumberText(gemText)

        local playerGui = player:WaitForChild("PlayerGui")
        local function createMessage(name, text, bgColor, position)
            if playerGui:FindFirstChild(name) then
                playerGui[name]:Destroy()
            end

            local screenGui = Instance.new("ScreenGui")
            screenGui.Name = name
            screenGui.ResetOnSpawn = false
            screenGui.Parent = playerGui

            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(0, 200, 0, 50)
            label.Position = position
            label.BackgroundColor3 = bgColor
            label.TextColor3 = Color3.new(1, 1, 1)
            label.Text = text
            label.Font = Enum.Font.SourceSansBold
            label.TextScaled = true
            label.Parent = screenGui
        end



        local function EquipReloadSkill()
            local args = {
                "S_Equipment",
                "Unlock",
                { "74", "73", "72", "71", "70" }
            }
            game:GetService("ReplicatedStorage")
                :WaitForChild("Assets")
                :WaitForChild("Remotes")
                :WaitForChild("GET")
                :InvokeServer(unpack(args))
            createMessage("EquipReloadSkill", "EquipReloadSkill !!!", Color3.fromRGB(0, 255, 0),
                UDim2.new(0.5, -100, 0.5, -50))
            task.wait(1)
        end

        local HttpService = game:GetService("HttpService")
        local folderName = "PlayersData"
        local filename = folderName .. "/" .. player.Name .. ".json"

        local ok, dataWorkspace = pcall(function()
            local content = readfile(filename)
            return HttpService:JSONDecode(content)
        end)

        if not ok then
            warn("Failed to read file: " .. tostring(dataWorkspace))
            return
        end

        local isReadyUnloackReloadSkill = dataWorkspace.isReadyEquidReloadSkill
        local isReadyUnloackTwoSkill = dataWorkspace.isReadyUnloackTwoSkill


        if not isfile or not isfile(filename) then
            warn("File not found: " .. filename)
            return
        end

        local GET = ReplicatedStorage.Assets.Remotes.GET

        local function unlockEquipment(ids)
            GET:InvokeServer(table.unpack({
                "S_Equipment",
                "Unlock",
                ids
            }))
        end

        -- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏™‡∏Å‡∏¥‡∏•
        local function setSkillState(slot, id)
            GET:InvokeServer(table.unpack({
                "S_Equipment",
                "Skill_State",
                slot,
                id
            }))
        end

        local function EquipTwoSkillRemote()
            -- ‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå ID 1-14 ‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Skill Slot 1 ‡πÄ‡∏õ‡πá‡∏ô ID 14
            unlockEquipment({
                "14", "13", "12", "11", "10", "9", "8",
                "7", "6", "5", "4", "3", "2", "1"
            })
            setSkillState(1, "14")

            -- ‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå ID 15-23 ‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Skill Slot 2 ‡πÄ‡∏õ‡πá‡∏ô ID 23
            unlockEquipment({
                "23", "22", "21", "20", "19", "18",
                "17", "16", "15"
            })
            setSkillState(2, "23")
            createMessage("EquipTwoSkill", "EquipTwoSkill !!!", Color3.fromRGB(0, 255, 0),
                UDim2.new(0.5, -100, 0.5, -100))
            task.wait(1)
        end

        if (skillPoint >= 10) and (gold >= 15000) and (LevelGui >= 10) and (isReadyUnloackReloadSkill == true) then
            EquipReloadSkill()

            local isEditOk, err = pcall(function()
                dataWorkspace.isReadyEquidReloadSkill = false
                writefile(filename, HttpService:JSONEncode(dataWorkspace))
            end)
        end

        if (LevelGui >= 70) and (gold >= 100000) and (isReadyUnloackTwoSkill == true) then
            if ((LevelGui - 10) == skillPoint) and (isReadyUnloackReloadSkill == false) then
                EquipTwoSkillRemote()

                local isEditOk, err = pcall(function()
                    dataWorkspace.isReadyUnloackTwoSkill = false
                    writefile(filename, HttpService:JSONEncode(dataWorkspace))
                end)
            end
        end

        local talentsList = {
            "Crescendo", "Blitzblade", "Swiftshot", "Surgeshot", "Stalwart",
            "Stormcharged", "Quakestrike", "Furyforge", "Assassin", "Amputation",
            "Marksman", "Guardian", "Deflectra",
            "Aegisurge", "Riposte", "Resilience", "Vengeflare", "Steel Frame", "Cooldown Blitz", "Mendmaster", "Lifefeed",
            "Vitalize", "Gem", "Fiend", "Omnirange", "Flashstep", "Tactician"
        }

        local function rejoinServer()
            local ts = game:GetService("TeleportService")
            local p = game:GetService("Players").LocalPlayer
            ts:TeleportToPlaceInstance(game.PlaceId, game.JobId, p)
        end

        local function equipPerkRemote()
            local perkItem = playerGui:FindFirstChild("Interface")
                and playerGui.Interface.Equipment.Perk_List.Holder.Items
            if not perkItem then
                dataWorkspace.continueToFindPerk = 30
                createMessage("NoPerk", "NoPerk !!!", Color3.fromRGB(255, 255, 0),
                    UDim2.new(0.5, -100, 0.5, -30))
                return
            end

            local function equipPerk(item)
                local args = {
                    "S_Equipment",
                    "Perk_State",
                    item:GetAttribute("ID"), -- ‡∏î‡∏∂‡∏á ID ‡∏à‡∏≤‡∏Å Attribute
                    "Equip",
                    "Body"
                }
                GET:InvokeServer(unpack(args))
            end

            local carnifex = perkItem:FindFirstChild("K_300_Carnifex")
            local butcher = perkItem:FindFirstChild("K_400_Butcher")


            if carnifex then
                equipPerk(carnifex)
                dataWorkspace.isReadyEquidPerk = false
                createMessage("SetCaniFexPerk", "SetCaniFex Perk !!!", Color3.fromRGB(255, 255, 0),
                    UDim2.new(0.5, -100, 0.5, -10))
            elseif butcher then
                equipPerk(butcher)
                dataWorkspace.isReadyEquidPerk = false
                createMessage("SetButcherPerk", "SetCaniFex Perk !!!", Color3.fromRGB(255, 255, 0),
                    UDim2.new(0.5, -100, 0.5, -20))
            else
                dataWorkspace.continueToFindPerk = 30
                createMessage("NoPerk", "NoPerk !!!", Color3.fromRGB(255, 255, 0),
                    UDim2.new(0.5, -100, 0.5, -30))
            end
        end

        local function AutoPrestigeRemote()
            for _, talent in ipairs(talentsList) do
                -- ‡∏¢‡∏¥‡∏á remote ‡∏Ç‡∏≠ Talent ‡∏Å‡πà‡∏≠‡∏ô
                local args1 = {
                    "S_Equipment",
                    "Talents"
                }
                game:GetService("ReplicatedStorage"):WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("GET")
                    :InvokeServer(unpack(args1))
                task.wait(0.1)

                -- ‡∏¢‡∏¥‡∏á remote ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏∏‡∏ï‡∏¥
                local args2 = {
                    "S_Equipment",
                    "Prestige",
                    {
                        Boosts = "Gold Boost",
                        Talents = talent
                    }
                }
                game:GetService("ReplicatedStorage"):WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("GET")
                    :InvokeServer(unpack(args2))
            end
            -- ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏à‡∏∏‡∏ï‡∏¥‡∏Å‡πà‡∏≠‡∏ô‡∏¢‡∏¥‡∏á‡∏≠‡∏±‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏õ
            createMessage("PrestigeRemote", "PrestigeRemote !!!", Color3.fromRGB(255, 255, 0),
                UDim2.new(0.5, -100, 0.5, -25))
            task.wait(50)

            -- ‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
            dataWorkspace.isReadyEquidReloadSkill = true
            dataWorkspace.isReadyUnloackTwoSkill = true
            dataWorkspace.numberRoundPlay = 0 -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0
            dataWorkspace.level = 0           -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0
            dataWorkspace.missionDif = "Easy"
            dataWorkspace.continueMission = 0 -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0
            dataWorkspace.continueToFindPerk = 0
            dataWorkspace.numberRoundPlay = 0
            dataWorkspace.rejoinThreshold = math.random(60, 80)
            writefile(filename, HttpService:JSONEncode(dataWorkspace))
            rejoinServer()
        end

        -- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ã‡πâ‡∏≤‡∏¢
        function SimulateLeftClick(x, y)
            VirtualInputManager:SendMouseMoveEvent(x, y, game)
            task.wait()

            VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 0)
            task.wait()
            VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 0)
            task.wait()
        end

        local modifiers = {
            "No Perks",
            --"No Skills",
            "No Talents",
            "Nightmare",
            "Injury Prone",
            "Chronic Injuries",
            "Fog",
            "Glass Cannon",
            "Time Trial",
            "Boring",
            "Simple",
        }

        local function getMaxChecksFromGearRank(rankArgument)
            local index = table.find(gearRanks, rankArgument)
            if not index then return 3 end -- fallback ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ rank

            if index < 6 then              -- E- ‡∏ñ‡∏∂‡∏á D
                return 5
            elseif index < 9 then          -- D+ ‡∏ñ‡∏∂‡∏á C
                return 3
            elseif index <= 12 then        -- C+ ‡∏ñ‡∏∂‡∏á B+
                return 4
            elseif index < 18 then         -- A- ‡∏ñ‡∏∂‡∏á S+
                return 3
            else
                return 3
            end
        end

        local function performFixedRounds(rankArgument)
            local limitChecks = getMaxChecksFromGearRank(rankArgument)
            for round = 1, limitChecks do
                for _, upgradeName in ipairs(upgrades) do
                    RemoteFunction:InvokeServer(unpack({
                        "S_Equipment",
                        "Upgrade",
                        upgradeName
                    }))
                    task.wait(0.1)
                end
            end
        end

        local function performOneRound()
            local limitChecks = 1
            for round = 1, limitChecks do
                for _, upgradeName in ipairs(upgrades) do
                    RemoteFunction:InvokeServer(unpack({
                        "S_Equipment",
                        "Upgrade",
                        upgradeName
                    }))
                    task.wait(0.1)
                end
            end
        end

        local function showOkMessage()
            local screenGui = Instance.new("ScreenGui")
            screenGui.Name = "UpgradeOkMessageGui"
            screenGui.ResetOnSpawn = false
            screenGui.Parent = playerGui

            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(0, 200, 0, 50)
            label.Position = UDim2.new(0.5, -100, 0.5, -25)
            label.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
            label.TextColor3 = Color3.new(1, 1, 1)
            label.Text = "Upg OK!!"
            label.Font = Enum.Font.SourceSansBold
            label.TextScaled = true
            label.Parent = screenGui
        end

        local function getMissionDifficultyFromGearRank(gearRank, offset)
            local indexMapMission = {}
            for i, rank in ipairs(gearRanks) do
                indexMapMission[rank] = i
            end

            local idx = indexMapMission[gearRank]
            if not idx then return "Easy" end

            -- ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ offset (‡πÄ‡∏ä‡πà‡∏ô +1) ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô rank ‡∏Ç‡∏∂‡πâ‡∏ô
            if offset then
                idx = math.clamp(idx + offset, 1, #gearRanks)
            end

            if idx >= 1 and idx <= 5 then
                return "Easy"
            elseif idx >= 6 and idx <= 8 then
                return "Normal"
            elseif idx >= 9 and idx <= 12 then
                return "Hard"
            elseif idx >= 13 and idx <= 15 then
                return "Severe"
            elseif idx >= 16 and idx <= 18 then
                return "Aberrant"
            else
                return "Easy"
            end
        end

        local difficultyOffset = nil -- ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏™‡πà nil ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏Å
        local mission_diff = getMissionDifficultyFromGearRank(extractedGrade, difficultyOffset)


        local prestigeTextGui = game:GetService("Players").LocalPlayer.PlayerGui.Interface.Equipment.Prestige.Progress
            .Level
            .Text
        local maxLevelPres = prestigeTextGui:match("/%s*(%d+)$")
        local maxLevelPrestige = tonumber(maxLevelPres)
        local levelMap = {
            [100] = 0,
            [125] = 1,
            [150] = 2
        }


        local levelMapSheet = {
            [100] = "0",
            [125] = "1",
            [150] = "2",
        }

        local maxLevelPrestigeSheet

        -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏õ‡πá‡∏ô MAX LVL
        if prestigeTextGui:match("MAX%s*LVL") then
            maxLevelPrestigeSheet = "Max"
        else
            local maxLevelPresSheet = prestigeTextGui:match("/%s*(%d+)$")
            maxLevelPrestigeSheet = tonumber(maxLevelPresSheet)
            maxLevelPrestigeSheet = levelMapSheet[maxLevelPrestigeSheet] or maxLevelPrestigeSheet
        end

        local function LoadDataToRAM()
            -- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤
            local API_URL_SetDescription = "http://localhost:7963/SetDescription"


            -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏õ‡πá‡∏ô MAX LVL
            if prestigeTextGui:match("MAX%s*LVL") then
                maxLevelPrestigeSheet = "Max"
            else
                local maxLevelPresSheet = prestigeTextGui:match("/%s*(%d+)$")
                maxLevelPrestigeSheet = tonumber(maxLevelPresSheet)
                maxLevelPrestigeSheet = levelMapSheet[maxLevelPrestigeSheet] or maxLevelPrestigeSheet
            end

            local function setDescription(accountName, descriptionText)
                local url = API_URL_SetDescription .. "?Account=" .. HttpService:UrlEncode(accountName)

                local success, response = pcall(function()
                    return request({
                        Url = url,
                        Method = "POST",
                        Headers = {
                            ["Content-Type"] = "text/plain"
                        },
                        Body = descriptionText
                    })
                end)

                if success then
                    if response.StatusCode == 200 then
                        return true
                    else
                        warn("‚ùå Description - Status Code: " .. response.StatusCode)
                        warn("Response: " .. (response.Body or "‡πÑ‡∏°‡πà‡∏°‡∏µ response"))
                        return false
                    end
                else
                    warn("‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ API (Description): " .. tostring(response))
                    return false
                end
            end

            local descriptionText = "Gold: " ..
                goldText ..
                " | Gem: " .. gemText ..
                " | Level: " .. LevelGuiString ..
                " | Prestige: " .. maxLevelPrestigeSheet

            if (game.PlaceId == 14916516914) or (game.PlaceId == 15220308770) then
                task.wait(math.random(1, 2))
                local resultSetDescription = setDescription(player.Name, descriptionText)
            end
        end

        LoadDataToRAM()





        -- ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÉ‡∏ô map ‡∏Å‡πá‡πÄ‡∏≠‡∏≤‡∏ï‡∏≤‡∏°‡∏ô‡∏±‡πâ‡∏ô ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏à‡∏∞‡πÑ‡∏î‡πâ nil
        maxLevelPrestige = levelMap[maxLevelPrestige] or maxLevelPrestige
        local xpText = game:GetService("Players").LocalPlayer.PlayerGui.Interface.Equipment.Prestige.Progress.XP.Text
        local currentXpStr, maxXpStr = xpText:match("([%d,]+)%s*/%s*([%d,]+)")
        local function toNumberSafe(str)
            if not str then return 0 end
            str = str:gsub("[^%d]", "") -- ‡πÄ‡∏≠‡∏≤‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏≠‡∏≠‡∏Å‡∏°‡∏≤
            return tonumber(str) or 0
        end

        local currentXp = toNumberSafe(currentXpStr)
        local maxXp = toNumberSafe(maxXpStr)

        dataWorkspace.level = LevelGui
        if (prestigeTextGui ~= "MAX LVL") then
            dataWorkspace.prestigeLevel = maxLevelPrestige
        end
        dataWorkspace.missionDif = mission_diff
        dataWorkspace.goldWorkSpace = gold
        dataWorkspace.gemWorkSpace = gem

        -- ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Ñ‡πà‡∏≤ continueMission
        if (LevelGui == 100 and prestigeTextGui == "MAX LVL") or (prestigeTextGui == "MAX LVL" and LevelGui == 125)
            and (currentXp ~= maxXp) then
            dataWorkspace.continueMission = 5
        end

        local offensePerkButtonGUI = game:GetService("Players").LocalPlayer.PlayerGui.Interface.Equipment.Perk_List
            .Types.Offense.Inner.Interact


        -- ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
        writefile(filename, HttpService:JSONEncode(dataWorkspace))


        if (LevelGui == 100 and prestigeTextGui == "MAX LVL" and currentXp == maxXp)
            or (LevelGui == 125 and prestigeTextGui == "MAX LVL" and currentXp == maxXp) then
            AutoPrestigeRemote()
        end

        local function createMission(difficulty, missionType, name, objective)
            local args = { "S_Missions", "Create", {
                ["Difficulty"] = difficulty,
                ["Type"] = missionType,
                ["Name"] = name,
                ["Objective"] = objective
            } }
            return RemoteFunction:InvokeServer(unpack(args))
        end

        local function modifyMission(modifier)
            local args = { "S_Missions", "Modify", modifier }
            return RemoteFunction:InvokeServer(unpack(args))
        end

        local function startMission()
            local args = { "S_Missions", "Start" }
            return RemoteFunction:InvokeServer(unpack(args))
        end

        if LevelGui >= 85 then
            for i, v in ipairs(modifiers) do
                if v == "No Perks" then
                    table.remove(modifiers, i)
                    break
                end
            end
        end

        if not (extractedGrade == "S" or extractedGrade == "S+" or extractedGrade == "S-") then
            if (extractedGrade == "E-" and gold >= 100000) or (extractedGrade == "D+" and gold >= 300000)
                or (extractedGrade == "C+" and gold >= 1500000) or (extractedGrade == "A-" and gold >= 3300000)
                or (extractedGrade == "A" and gold >= 1500000) or (extractedGrade == "A+" and gold >= 1500000) then
                performFixedRounds(extractedGrade)
                showOkMessage()
                task.wait(0.5)
                mission_diff = getMissionDifficultyFromGearRank(extractedGrade, getMaxChecksFromGearRank(extractedGrade))
                createMission(mission_diff, "Missions", "Utgard", "Skirmish")
                for _, modifier in ipairs(modifiers) do
                    modifyMission(modifier)
                    task.wait(0.1)
                end
                startMission()
                task.wait(0.5)
            elseif
                (extractedGrade == "E" and gold >= 10000) or (extractedGrade == "E+" and gold >= 16000) or
                (extractedGrade == "D-" and gold >= 24000) or (extractedGrade == "D" and gold >= 40000) or
                (extractedGrade == "C-" and gold >= 88000) or (extractedGrade == "C" and gold >= 140000) or
                (extractedGrade == "B-" and gold >= 300000) or (extractedGrade == "B" and gold >= 400000) or (extractedGrade == "B+" and gold >= 560000) then
                performOneRound()
                createMission(mission_diff, "Missions", "Utgard", "Skirmish")
                for _, modifier in ipairs(modifiers) do
                    modifyMission(modifier)
                    task.wait(0.1)
                end
                startMission()
            else
                createMission(mission_diff, "Missions", "Utgard", "Skirmish")
                for _, modifier in ipairs(modifiers) do
                    modifyMission(modifier)
                    task.wait(0.1)
                end
                startMission()
            end
        else
            createMission(mission_diff, "Missions", "Utgard", "Skirmish")
            for _, modifier in ipairs(modifiers) do
                modifyMission(modifier)
                task.wait(0.1)
            end
            startMission()
        end
    end)
end

-- === BLACK OVERLAY ===
RunConcurrent(function()
    repeat task.wait() until game:IsLoaded()
    task.wait(5)
    -- Black Screen Overlay with Kill Counter (Ultra Lightweight)
    -- This creates a black overlay with kill counter that doesn't consume much resources

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer

    -- Wait for PlayerGui
    local playerGui = LocalPlayer:WaitForChild("PlayerGui")

    -- Variables for kill tracking
    local killLabel = nil
    local lastUpdateTime = 0

    -- Optimized kill count function
    local function GetKillInfo()
        local success, currentKill, maxKill = pcall(function()
            local gui = LocalPlayer.PlayerGui
            local text = gui.Interface.HUD.Objectives.Main.Slay.Text
            local current, max = string.match(text, "%[(%d+)%/(%d+)%]")
            return tonumber(current), tonumber(max)
        end)
        return success and currentKill or 0, success and maxKill or 0
    end

    -- Create the black overlay with kill counter
    local function CreateBlackOverlay()
        -- Check if overlay already exists
        local existingOverlay = playerGui:FindFirstChild("BlackOverlay")
        if existingOverlay then
            existingOverlay:Destroy()
        end

        -- Create ScreenGui
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "BlackOverlay"
        screenGui.ResetOnSpawn = false
        screenGui.IgnoreGuiInset = true
        screenGui.DisplayOrder = -1000 -- Put it behind other UIs
        screenGui.Parent = playerGui

        -- Create black frame
        local blackFrame = Instance.new("Frame")
        blackFrame.Name = "BlackFrame"
        blackFrame.Size = UDim2.new(1, 0, 1, 0)
        blackFrame.Position = UDim2.new(0, 0, 0, 0)
        blackFrame.BackgroundColor3 = Color3.new(0, 0, 0) -- Pure black
        blackFrame.BorderSizePixel = 0
        blackFrame.Active = false                         -- Don't capture input
        blackFrame.Parent = screenGui

        -- Create kill counter label (simple white text)
        killLabel = Instance.new("TextLabel")
        killLabel.Name = "KillCounter"
        killLabel.Size = UDim2.new(0, 200, 0, 50)
        killLabel.Position = UDim2.new(0.5, -100, 0.5, -25) -- Center of screen
        killLabel.BackgroundTransparency = 1                -- Transparent background
        killLabel.Text = "Kills: 0/0"
        killLabel.TextColor3 = Color3.new(1, 1, 1)          -- White text
        killLabel.TextSize = 24
        killLabel.Font = Enum.Font.Code                     -- Simple font
        killLabel.TextStrokeTransparency = 0.5              -- Slight outline for visibility
        killLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        killLabel.Active = false
        killLabel.Parent = blackFrame


        return screenGui
    end

    -- Create the overlay
    local overlay = CreateBlackOverlay()

    -- Ultra lightweight update function (updates only every 0.5 seconds)
    local connection = RunService.Heartbeat:Connect(function()
        local currentTime = tick()
        if currentTime - lastUpdateTime >= 0.5 and killLabel and killLabel.Parent then -- Update every 0.5 seconds only
            lastUpdateTime = currentTime
            local currentKill, maxKill = GetKillInfo()
            killLabel.Text = string.format("Kills: %d/%d", currentKill, maxKill)
        end
    end)

    -- Optional: Add toggle functionality (press F1 to toggle)
    local UserInputService = game:GetService("UserInputService")

    UserInputService.InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.F1 then
            if overlay and overlay.Parent then
                overlay.BlackFrame.Visible = not overlay.BlackFrame.Visible
            end
        end
    end)

    -- Cleanup when overlay is destroyed
    overlay.AncestryChanged:Connect(function()
        if not overlay.Parent then
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end)
end)

-- ========== V9 ==========
